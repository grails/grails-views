Although generally testing can be done using functional tests via an HTTP client, the JSON views plugin also provides a trait which helps in writing either unit or integration tests.


To use the trait import the `grails.plugin.json.view.test.JsonViewTest` class and apply it to any Spock or JUnit test:

[source,groovy]
import grails.plugin.json.view.test.*
import spock.lang.Specification
class MySpec extends Specification implements JsonViewTest {
    ...
}

The trait provides a number of different `render` method implementations that can either render a JSON view found in `grails-app/views` or render an inline String. For example to render an inline template:

[source,groovy]
----
void "Test render a raw GSON view"() {
    when:"A gson view is rendered"
    JsonRenderResult result = render '''
        model {
            String person
        }
        json.person {
            name person
        }
''', [person:"bob"] <1>

    then:"The json is correct"
    result.json.person.name == 'bob' <2>
}
----

<1> Use the `render` method to return a `JsonRenderResult` passing in a String that is the inline template and a map that is the model
<2> Assert the parsed JSON, represented by the `json` property, is correct

To render an existing view or template pass use named arguments to specify an absolute path to either a template or a view:

[source,groovy]
----
when:"A gson view is rendered"
def result = render(template: "/path/to/template", model:[age:10])

then:"The json is correct"
result.json.name == 'Fred'
result.json.age == 10
----

If you are writing a unit test, and the model involves a domain class, you may need to add the domain class to the `mappingContext` object in order for it to be rendered correctly:

[source,groovy]
----
when:"A gson view is rendered for a domain class"
mappingContext.addPersistentEntity(MyDomain)
def result = render(template: "/path/to/template", model:[myDomain:MyDomain])

then:"The json is correct"
result.json.name == 'Fred'
result.json.age == 10
----